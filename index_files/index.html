<!DOCTYPE html>
<!-- saved from url=(0114)https://httpsf5was1w9fwfmsitescom.webpush.in.freshchat.com/index.html?ref=aHR0cHM6Ly9mNXdhczF3OS5md2Ztc2l0ZXMuY29t -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title class="title">Freshchat Web Push Notification</title>
      <meta name="description" content="">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link type="application/json" rel="manifest" href="https://httpsf5was1w9fwfmsitescom.webpush.in.freshchat.com/manifest.json">
      <style type="text/css">
         body{
         background: #7C8A9C;
         margin: 0;
         font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Arial, sans-serif;
         color: #413F3F;
         font-size: 14px;
         -webkit-font-smoothing: antialiased;
         text-rendering: optimizeLegibility;
         }
         #footer {
         bottom: 0px;
         text-align: center;
         width: 100%;
         background: #E6EFF7;
         font-size: 14px;
         display: inline-block;
         border-radius: 0 0 10px 10px;
         padding: 20px 0;
         }
         #footer .text p{
         margin: 0;
         font-size: 16px;
         padding: 10px 30px;
         }
         #bottom{
     position: absolute;
       width: 100%;
       top: 100%;
       text-align: center;
      }
         #bottom p {    font-size: 11px;
         padding: 10px 0 10px;
         color: #E6EFF7;
         margin: 0}
         #bottom p .red {color: #FFF; text-decoration: none}
         #main {
         position: absolute;
         height: 100%;
         width: 100%;
         vertical-align: middle;
         }
         #main .middle {
         background: #FFF;
         min-width: 300px;
         max-width: 400px;
         width: 90%;
         position: absolute;
         border-radius: 10px;
         top: 50%;
         transform: translateX(-50%) translateY(-50%);
         left: 50%;
         box-shadow: 0 0 20px rgba(0,0,0,0.3);
         }
         #main .middle .inner {
         margin-left: auto;
         margin-right: auto;
         text-align: center;
         padding:  30px 15px;
         }
      #main .middle .inner p{
        margin: 0;
        padding: 0;
      }
         #main .middle .inner p img {
         height: 60px;
         /*      display: none;*/
         }
      </style>
   <script type="text/javascript" src="chrome-extension://mdnleldcmiljblolnjhpnblkcekpdkpa/libs/customElements.js" class="__REQUESTLY__SCRIPT"></script><script type="text/javascript" class="__REQUESTLY__SCRIPT">((namespace) => {
  const RuleSourceKey = {
    URL: "Url",
    HOST: "host",
    PATH: "path",
  };

  const RuleSourceOperator = {
    EQUALS: "Equals",
    CONTAINS: "Contains",
    MATCHES: "Matches",
    WILDCARD_MATCHES: "Wildcard_Matches",
  };

  const toRegex = (regexStr) => {
    const matchRegExp = regexStr.match(new RegExp("^/(.+)/(|i|g|ig|gi)$"));

    if (!matchRegExp) {
      return null;
    }

    try {
      return new RegExp(matchRegExp[1], matchRegExp[2]);
    } catch {
      return null;
    }
  };

  const checkRegexMatch = (regexString, inputString) => {
    if (!regexString.startsWith("/")) {
      regexString = `/${regexString}/`; // Keeping enclosing slashes for regex as optional
    }

    const regex = toRegex(regexString);
    return regex?.test(inputString);
  };

  const checkWildCardMatch = (wildCardString, inputString) => {
    const regexString = "/^" + wildCardString.replaceAll("*", ".*") + "$/";
    return checkRegexMatch(regexString, inputString);
  };

  const extractUrlComponent = (url, key) => {
    const urlObj = new URL(url);

    switch (key) {
      case RuleSourceKey.URL:
        return url;
      case RuleSourceKey.HOST:
        return urlObj.host;
      case RuleSourceKey.PATH:
        return urlObj.pathname;
    }
  };

  window[namespace] = window[namespace] || {};
  window[namespace].matchSourceUrl = (sourceObject, url) => {
    const urlComponent = extractUrlComponent(url, sourceObject.key);
    const value = sourceObject.value;

    if (!urlComponent) {
      return false;
    }

    switch (sourceObject.operator) {
      case RuleSourceOperator.EQUALS:
        if (value === urlComponent) {
          return true;
        }
        break;

      case RuleSourceOperator.CONTAINS:
        if (urlComponent.indexOf(value) !== -1) {
          return true;
        }
        break;

      case RuleSourceOperator.MATCHES: {
        return checkRegexMatch(value, urlComponent);
      }

      case RuleSourceOperator.WILDCARD_MATCHES: {
        return checkWildCardMatch(value, urlComponent);
      }
    }

    return false;
  };
})('__REQUESTLY__')</script><script type="text/javascript" class="__REQUESTLY__SCRIPT">(function ({
  namespace,
  customHeaderPrefix = "",
  ignoredHeadersOnRedirect = [],
}) {
  window[namespace] = window[namespace] || {};
  window[namespace].requestRules = [];
  window[namespace].responseRules = [];
  window[namespace].redirectRules = [];
  window[namespace].replaceRules = [];
  let isDebugMode = false;

  // Some frames are sandboxes and throw DOMException when accessing localStorage
  try {
    isDebugMode = window && window.localStorage && localStorage.isDebugMode;
  } catch (e) {}

  const isExtensionEnabled = () => {
    return window[namespace].isExtensionEnabled ?? true;
  };

  const getAbsoluteUrl = (url) => {
    const dummyLink = document.createElement("a");
    dummyLink.href = url;
    return dummyLink.href;
  };

  const isNonJsonObject = (obj) => {
    return [
      Blob,
      ArrayBuffer,
      Object.getPrototypeOf(Uint8Array), // TypedArray instance type
      DataView,
      FormData,
      URLSearchParams,
    ].some((nonJsonType) => obj instanceof nonJsonType);
  };

  /**
   * @param {Object} json
   * @param {String} path -> "a", "a.b", "a.0.b (If a is an array containing list of objects"
   * Also copied in shared/utils.js for the sake of testing
   */
  const traverseJsonByPath = (jsonObject, path) => {
    if (!path) return;

    const pathParts = path.split(".");

    try {
      // Reach the last node but not the leaf node.
      for (i = 0; i < pathParts.length - 1; i++) {
        jsonObject = jsonObject[pathParts[i]];
      }

      return jsonObject[pathParts[pathParts.length - 1]];
    } catch (e) {
      /* Do nothing */
    }
  };

  const matchesSourceFilters = ({ requestData, method }, sourceFilters) => {
    const sourceFiltersArray = Array.isArray(sourceFilters) ? sourceFilters : [sourceFilters];

    return (
      !sourceFiltersArray.length ||
      sourceFiltersArray.some((sourceFilter) => {
        if (sourceFilter?.requestMethod?.length && !sourceFilter.requestMethod.includes(method)) {
          return false;
        }

        let requestPayloadFilter = sourceFilter?.requestPayload;

        if (!requestPayloadFilter) return true;
        if (typeof requestPayloadFilter === "object" && Object.keys(requestPayloadFilter).length === 0) return true;

        // We only allow request payload targeting when requestData is JSON
        if (!requestData || typeof requestData !== "object") return false;
        if (Object.keys(requestData).length === 0) return false;

        requestPayloadFilter = requestPayloadFilter || {};
        const targetedKey = requestPayloadFilter?.key;
        const targetedValue = requestPayloadFilter?.value;

        // tagetedKey is the json path e.g. a.b.0.c
        if (targetedKey && typeof targetedValue !== undefined) {
          const valueInRequestData = traverseJsonByPath(requestData, targetedKey);
          const operator = requestPayloadFilter?.operator;

          if (!operator || operator === "Equals") {
            return valueInRequestData === targetedValue;
          }

          if (operator === "Contains") {
            return valueInRequestData.includes(targetedValue);
          }
        }

        return false;
      })
    );
  };

  const matchRuleSource = ({ url, requestData, method }, rule) => {
    const modification = rule.pairs[0];
    const ruleSource = modification.source;

    return (
      window[namespace].matchSourceUrl(ruleSource, url) &&
      matchesSourceFilters({ requestData, method }, ruleSource?.filters)
    );
  };

  const getRequestRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].requestRules?.findLast((rule) =>
      window[namespace].matchSourceUrl(rule.pairs[0].source, url)
    );
  };

  const getResponseRule = ({ url, requestData, method }) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].responseRules?.findLast((rule) => {
      return matchRuleSource({ url, requestData, method }, rule);
    });
  };

  const getMatchingRedirectRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].redirectRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const getMatchingReplaceRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].replaceRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const shouldServeResponseWithoutRequest = (responseRule) => {
    const responseModification = responseRule.pairs[0].response;
    return responseModification.type === "static" && responseModification.serveWithoutRequest;
  };

  const getFunctionFromCode = (code) => {
    return new Function("args", `return (${code})(args);`);
  };

  const getCustomRequestBody = (requestRule, args) => {
    const modification = requestRule.pairs[0].request;
    if (modification.type === "static") {
      requestBody = modification.value;
    } else {
      requestBody = getFunctionFromCode(modification.value)(args);
    }

    if (typeof requestBody !== "object" || isNonJsonObject(requestBody)) {
      return requestBody;
    }

    return JSON.stringify(requestBody);
  };

  /**
   * @param mightBeJSONString string which might be JSON String or normal String
   * @param doStrictCheck should return empty JSON if invalid JSON string
   */
  const jsonifyValidJSONString = (mightBeJSONString, doStrictCheck) => {
    const defaultValue = doStrictCheck ? {} : mightBeJSONString;

    if (typeof mightBeJSONString !== "string") {
      return defaultValue;
    }

    try {
      return JSON.parse(mightBeJSONString);
    } catch (e) {
      /* Do Nothing. Unable to parse the param value */
    }

    return defaultValue;
  };

  const isJSON = (data) => {
    const parsedJson = jsonifyValidJSONString(data);
    return parsedJson !== data; // if data is not a JSON, jsonifyValidJSONString() returns same value
  };

  const notifyRequestRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "request_rule_applied",
        id: message.ruleDetails.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const notifyResponseRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "response_rule_applied",
        id: message.rule.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const isPromise = (obj) =>
    !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";

  const isContentTypeJSON = (contentType) => !!contentType?.includes("application/json");

  // XHR Implementation
  const updateXhrReadyState = (xhr, readyState) => {
    Object.defineProperty(xhr, "readyState", { writable: true });
    xhr.readyState = readyState;
    xhr.dispatchEvent(new CustomEvent("readystatechange"));
  };

  const resolveXHR = (xhr, responseData) => {
    xhr.dispatchEvent(new ProgressEvent("loadstart"));

    // update response headers
    const contentType = isJSON(responseData) ? "application/json" : "text/plain";
    xhr.getResponseHeader = (key) => {
      if (key.toLowerCase() === "content-type") {
        return contentType;
      }
      return null;
    };
    updateXhrReadyState(xhr, xhr.HEADERS_RECEIVED);
    updateXhrReadyState(xhr, xhr.LOADING);

    // mark resolved
    updateXhrReadyState(xhr, xhr.DONE);
  };

  const OriginalXMLHttpRequest = XMLHttpRequest;

  const createProxyXHRObject = function () {
    const actualXhr = this;

    const dispatchEventToActualXHR = (type, e) => {
      isDebugMode && console.log("[RQ]", `on${type}`, e);
      actualXhr.dispatchEvent(
        new ProgressEvent(type, {
          lengthComputable: e?.lengthComputable,
          loaded: e?.loaded,
          total: e?.total,
        })
      );
    };

    const updateActualXHRReadyState = (readyState) => {
      updateXhrReadyState(actualXhr, readyState);
    };

    const onReadyStateChange = async function () {
      isDebugMode &&
        console.log("[RQ]", "onReadyStateChange", {
          state: this.readyState,
          status: this.status,
          response: this.response,
          xhr: this,
          url: this._requestURL,
        });
      if (!this.responseRule) {
        return;
      }
      const responseModification = this.responseRule.pairs[0].response;

      if (this.readyState === this.HEADERS_RECEIVED) {
        // For network failures, responseStatus=0 but we still return customResponse with status=200
        const responseStatus = parseInt(responseModification.statusCode || this.status) || 200;
        const responseStatusText = responseModification.statusText || this.statusText;

        Object.defineProperties(actualXhr, {
          status: {
            get: () => responseStatus,
          },
          statusText: {
            get: () => responseStatusText,
          },
          getResponseHeader: {
            value: this.getResponseHeader.bind(this),
          },
          getAllResponseHeaders: {
            value: this.getAllResponseHeaders.bind(this),
          },
        });

        updateActualXHRReadyState(this.HEADERS_RECEIVED);
      } else if (this.readyState === this.DONE) {
        const responseType = this.responseType;
        const contentType = this.getResponseHeader("content-type");

        let customResponse =
          responseModification.type === "code"
            ? getFunctionFromCode(responseModification.value)({
                method: this._method,
                url: this._requestURL,
                requestHeaders: this._requestHeaders,
                requestData: jsonifyValidJSONString(this._requestData),
                responseType: contentType,
                response: this.response,
                responseJSON: jsonifyValidJSONString(this.response, true),
              })
            : responseModification.value;

        // Convert customResponse back to rawText
        // response.value is String and evaluator method might return string/object
        if (isPromise(customResponse)) {
          customResponse = await customResponse;
        }

        isDebugMode &&
          console.log("[RQ]", "Rule Applied - customResponse", { customResponse, responseType, contentType });

        const isUnsupportedResponseType = responseType && !["json", "text"].includes(responseType);

        // We do not support statically modifying responses of type - blob, arraybuffer, document etc.
        if (responseModification.type === "static" && isUnsupportedResponseType) {
          customResponse = this.response;
        }

        if (
          !isUnsupportedResponseType &&
          typeof customResponse === "object" &&
          !(customResponse instanceof Blob) &&
          (responseType === "json" || isContentTypeJSON(contentType))
        ) {
          customResponse = JSON.stringify(customResponse);
        }
        Object.defineProperty(actualXhr, "response", {
          get: function () {
            if (responseModification.type === "static" && responseType === "json") {
              if (typeof customResponse === "object") {
                return customResponse;
              }

              return jsonifyValidJSONString(customResponse);
            }

            return customResponse;
          },
        });

        if (responseType === "" || responseType === "text") {
          Object.defineProperty(actualXhr, "responseText", {
            get: function () {
              return customResponse;
            },
          });
        }

        const responseURL = this.responseURL;
        const responseXML = this.responseXML;

        Object.defineProperties(actualXhr, {
          responseType: {
            get: function () {
              return responseType;
            },
          },
          responseURL: {
            get: function () {
              return responseURL;
            },
          },
          responseXML: {
            get: function () {
              return responseXML;
            },
          },
        });

        const requestDetails = {
          url: this._requestURL,
          method: this._method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        };

        // mark resolved)
        if (this._abort) {
          // Note: This might get delayed due to async in code block
          dispatchEventToActualXHR("abort");
          dispatchEventToActualXHR("loadend");
        } else {
          updateActualXHRReadyState(this.DONE);
          dispatchEventToActualXHR("load");
          dispatchEventToActualXHR("loadend");
        }

        notifyResponseRuleApplied({
          rule: this.responseRule,
          requestDetails,
        });
      } else {
        updateActualXHRReadyState(this.readyState);
      }
    };

    const xhr = new OriginalXMLHttpRequest();
    xhr.addEventListener("readystatechange", onReadyStateChange.bind(xhr), false);
    xhr.addEventListener("abort", dispatchEventToActualXHR.bind(xhr, "abort"), false);
    xhr.addEventListener("error", dispatchEventToActualXHR.bind(xhr, "error"), false);
    xhr.addEventListener("timeout", dispatchEventToActualXHR.bind(xhr, "timeout"), false);
    xhr.addEventListener("loadstart", dispatchEventToActualXHR.bind(xhr, "loadstart"), false);
    xhr.addEventListener("progress", dispatchEventToActualXHR.bind(xhr, "progress"), false);

    const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "timeout");

    Object.defineProperty(actualXhr, "timeout", {
      get: function () {
        return descriptor.get.call(this);
      },
      set: function (value) {
        xhr.timeout = value;
        descriptor.set.call(this, value);
      },
    });

    this.rqProxyXhr = xhr;
  };

  XMLHttpRequest = function () {
    const xhr = new OriginalXMLHttpRequest();
    createProxyXHRObject.call(xhr);
    return xhr;
  };

  XMLHttpRequest.prototype = OriginalXMLHttpRequest.prototype;
  Object.entries(OriginalXMLHttpRequest).map(([key, val]) => {
    XMLHttpRequest[key] = val;
  });

  const open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    this.rqProxyXhr._method = method;
    this.rqProxyXhr._requestURL = getAbsoluteUrl(url);
    open.apply(this.rqProxyXhr, arguments);
    open.apply(this, arguments);
  };

  const abort = XMLHttpRequest.prototype.abort;
  XMLHttpRequest.prototype.abort = function () {
    isDebugMode && console.log("abort called");
    this.rqProxyXhr._abort = true;
    abort.apply(this, arguments);
    abort.apply(this.rqProxyXhr, arguments);
  };

  let setRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
    this.rqProxyXhr._requestHeaders = this.rqProxyXhr._requestHeaders || {};
    this.rqProxyXhr._requestHeaders[header] = value;
    setRequestHeader.apply(this.rqProxyXhr, arguments);
    setRequestHeader.apply(this, arguments);
  };

  const send = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function (data) {
    this.rqProxyXhr._requestData = data;

    const requestRule = getRequestRule(this.rqProxyXhr._requestURL);
    if (requestRule) {
      this.rqProxyXhr._requestData = getCustomRequestBody(requestRule, {
        method: this.rqProxyXhr._method,
        url: this.rqProxyXhr._requestURL,
        body: data,
        bodyAsJson: jsonifyValidJSONString(data, true),
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url: this.rqProxyXhr._requestURL,
          method: this.rqProxyXhr._method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        },
      });
    }

    this.responseRule = getResponseRule({
      url: this.rqProxyXhr._requestURL,
      requestData: jsonifyValidJSONString(this.rqProxyXhr._requestData),
      method: this.rqProxyXhr._method,
    });
    this.rqProxyXhr.responseRule = this.responseRule;

    const redirectRuleThatMatchesURL = getMatchingRedirectRule(this.rqProxyXhr._requestURL);
    const replaceRuleThatMatchesURL = getMatchingReplaceRule(this.rqProxyXhr._requestURL);
    if (redirectRuleThatMatchesURL || replaceRuleThatMatchesURL) {
      ignoredHeadersOnRedirect.forEach((header) => {
        // Stores ignored header to be set on redirected URL. Refer: https://github.com/requestly/requestly/issues/1208
        const originalHeaderValue =
          this.rqProxyXhr._requestHeaders?.[header] || this.rqProxyXhr._requestHeaders?.[header.toLowerCase()];
        if (isExtensionEnabled() && originalHeaderValue) {
          this.setRequestHeader(customHeaderPrefix + header, originalHeaderValue);
        }
      });
    }

    if (this.responseRule) {
      isDebugMode && console.log("[RQ]", "send and response rule matched", this.responseRule);
      if (shouldServeResponseWithoutRequest(this.responseRule)) {
        isDebugMode && console.log("[RQ]", "send and response rule matched and serveWithoutRequest is true");
        resolveXHR(this.rqProxyXhr, this.responseRule.pairs[0].response.value);
      } else {
        send.call(this.rqProxyXhr, this.rqProxyXhr._requestData);
      }
      return;
    }

    send.call(this, this.rqProxyXhr._requestData);
  };

  // Intercept fetch API
  const _fetch = fetch;
  fetch = async (...args) => {
    const [resource, initOptions = {}] = args;
    const getOriginalResponse = () => _fetch(...args);

    let request;

    if (resource instanceof Request) {
      request = resource.clone();
    } else {
      request = new Request(resource.toString(), initOptions);
    }

    let hasModifiedHeaders = false;

    const url = getAbsoluteUrl(request.url);
    const method = request.method;

    const redirectRuleThatMatchesURL = getMatchingRedirectRule(url);
    const replaceRuleThatMatchesURL = getMatchingReplaceRule(url);

    // redirect/replace rule specific code that is applied only when redirect/replace rule matches the URL
    if (redirectRuleThatMatchesURL || replaceRuleThatMatchesURL) {
      // Stores Auth header to be set on redirected URL. Refer: https://github.com/requestly/requestly/issues/1208
      ignoredHeadersOnRedirect.forEach((header) => {
        const originalHeaderValue = request.headers.get(header);
        if (isExtensionEnabled() && originalHeaderValue) {
          hasModifiedHeaders = true;
          request.headers.set(customHeaderPrefix + header, originalHeaderValue);
        }
      });
    }

    // Request body can be sent only for request methods other than GET and HEAD.
    const canRequestBodyBeSent = !["GET", "HEAD"].includes(method);

    const requestRule = canRequestBodyBeSent && getRequestRule(url);
    if (requestRule) {
      const originalRequestBody = await request.text();
      const requestBody =
        getCustomRequestBody(requestRule, {
          method: request.method,
          url,
          body: originalRequestBody,
          bodyAsJson: jsonifyValidJSONString(originalRequestBody, true),
        }) || {};

      request = new Request(request.url, {
        method,
        body: requestBody,
        headers: request.headers,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url,
          method: request.method,
          type: "fetch",
          timeStamp: Date.now(),
        },
      });
    }

    let requestData;
    if (canRequestBodyBeSent) {
      requestData = jsonifyValidJSONString(await request.clone().text()); // cloning because the request will be used to make API call
    }

    const responseRule = getResponseRule({ url, requestData, method });
    let responseHeaders;
    let fetchedResponse;

    if (responseRule && shouldServeResponseWithoutRequest(responseRule)) {
      const contentType = isJSON(responseRule.pairs[0].response.value) ? "application/json" : "text/plain";
      responseHeaders = new Headers({ "content-type": contentType });
    } else {
      try {
        if (requestRule || hasModifiedHeaders) {
          // use modified request to fetch response
          fetchedResponse = await _fetch(request);
        } else {
          fetchedResponse = await getOriginalResponse();
        }

        if (!responseRule) {
          return fetchedResponse;
        }

        responseHeaders = fetchedResponse?.headers;
      } catch (error) {
        if (!responseRule) {
          return Promise.reject(error);
        }
      }
    }

    isDebugMode &&
      console.log("RQ", "Inside the fetch block for url", {
        url,
        resource,
        initOptions,
        fetchedResponse,
      });

    let customResponse;
    const responseModification = responseRule.pairs[0].response;

    if (responseModification.type === "code") {
      const requestHeaders =
        request.headers &&
        Array.from(request.headers).reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {});

      let evaluatorArgs = {
        method,
        url,
        requestHeaders,
        requestData,
      };

      if (fetchedResponse) {
        const fetchedResponseData = await fetchedResponse.text();
        const responseType = fetchedResponse.headers.get("content-type");
        const fetchedResponseDataAsJson = jsonifyValidJSONString(fetchedResponseData, true);

        evaluatorArgs = {
          ...evaluatorArgs,
          responseType,
          response: fetchedResponseData,
          responseJSON: fetchedResponseDataAsJson,
        };
      }

      customResponse = getFunctionFromCode(responseModification.value)(evaluatorArgs);

      // evaluator might return us Object but response.value is string
      // So make the response consistent by converting to JSON String and then create the Response object
      if (isPromise(customResponse)) {
        customResponse = await customResponse;
      }

      if (typeof customResponse === "object" && isContentTypeJSON(evaluatorArgs?.responseType)) {
        customResponse = JSON.stringify(customResponse);
      }
    } else {
      customResponse = responseModification.value;
    }

    const requestDetails = {
      url,
      method,
      type: "fetch",
      timeStamp: Date.now(),
    };

    notifyResponseRuleApplied({
      rule: responseRule,
      requestDetails,
    });

    // For network failures, fetchedResponse is undefined but we still return customResponse with status=200
    const finalStatusCode = parseInt(responseModification.statusCode || fetchedResponse?.status) || 200;
    const requiresNullResponseBody = [204, 205, 304].includes(finalStatusCode);

    return new Response(requiresNullResponseBody ? null : new Blob([customResponse]), {
      status: finalStatusCode,
      statusText: responseModification.statusText || fetchedResponse?.statusText,
      headers: responseHeaders,
    });
  };
})({"namespace":"__REQUESTLY__","customHeaderPrefix":"x-rq-","ignoredHeadersOnRedirect":["Authorization"]})</script></head>
   <body>
      <div id="main">
         <div class="middle">
            <div class="inner">
               <p><img src="./fc_logo.png"></p>
            </div>
            <div id="footer">
               <div class="text">
                  <p id="allow-notification">Click on “<strong>Allow</strong>“ to enable chat notifications</p>
                  <p id="help-text">Do not miss any conversations.</p>
               </div>
            </div>
            <div id="bottom">
                  <p id="powered-by">Powered by <a href="https://www.freshworks.com/live-chat-software/freshchat/" target="_blank" class="red">Freshchat</a></p>
               </div>
         </div>
      </div>
      <script>
         (function() {
           // Private Variables
           var referrer = undefined,
               action = undefined,
               appLogoPath = undefined,
               serviceWorkerUrl = '/firebase-sw.js',
               widget_location = '',
               locale="";

           // Private Methods
           var getQueryString = function( field, url ) {
                 var href = url ? url : window.location.href;
                 var reg = new RegExp( '[?&]' + field + '=([^&#]*)', 'i' );
                 var string = reg.exec(href);
                 return string ? string[1] : undefined;
               },
               initParams = function() {
                 var refString = getQueryString('ref'),
                     actionString = getQueryString('action'),
                     appLogoPathString = getQueryString('appLogoPath');
                     localeString = getQueryString('locale');
                 referrer = refString ? atob(refString) : '';
                 action = actionString ? atob(actionString) : '';
                 appLogoPath = appLogoPathString ? atob(appLogoPathString) : '';
                 locale =  localeString ? atob(localeString) : '';
               },
               updateUI = function() {
                 if(appLogoPath) {
                   var imgElement = document.querySelector("#main .middle .inner p img");
                   if (imgElement) {
                     imgElement.src = appLogoPath;
                     imgElement.style["display"] = "inline-block";
                   }
                 }
                let currentLocaleTranslation=currentLocaleTranslationString(locale);
                updateCurrentLocaleTranslationText(currentLocaleTranslation);
               },
               updateCurrentLocaleTranslationText=function(webPushTranslations){
                if(webPushTranslations){
                   if(webPushTranslations.title){
                    document.title = webPushTranslations.title
                   }
                   if(webPushTranslations.allow){
                    document.getElementById("allow-notification").innerHTML = webPushTranslations.allow;
                   }
                   if(webPushTranslations.helpText){
                    document.getElementById("help-text").innerHTML = webPushTranslations.helpText;
                   }
                   if(webPushTranslations.poweredBy){
                    document.getElementById("powered-by").innerHTML = webPushTranslations.poweredBy;
                   }
                  }
               },
               onMessage = function(event) {
                 // For Chrome, the origin property is in the event.originalEvent object.
                 var origin = event.origin || event.originalEvent.origin;
                 if (origin === referrer) {   // Trusted Sites
                   var data = event.data, action = data && data.action;
                   if (action) {
                     switch(action) {
                       case "widget_location":
                         widget_location = data.payload || '';
                         break;
                       case "get:subscription":
                         registerServiceWorker();
                         break;
                       case "clear:subscription":
                         unsubscribePush();
                         break;
                       default:
                         break;
                     }
                   }
                 }
               },
               onServiceWorkerMessage = function(event){
                 switch(event.data) {
                   case "get_widget_location":
                     event.ports[0].postMessage(widget_location);
                     break;
                 }
               },
               addMessagingEvents = function() {
                 if (window.addEventListener) {
                     window.addEventListener("message", onMessage, false);
                 } else {
                   window.attachEvent("onmessage", onMessage);
                 }
                 if('serviceWorker' in navigator){
                   // Handler for messages coming from the service worker
                   navigator.serviceWorker.addEventListener('message', onServiceWorkerMessage);
                 }
               },
               sendMessage = function(_subscription) {
                 var data = {
                       action: "push_user_meta",
                       data: {
                         permission: Notification.permission,
                         subscription: _subscription
                       }
                     };
                 if(window.opener) {
                   window.opener.postMessage(JSON.parse(JSON.stringify(data)), referrer);
                   window.close();
                 } else {
                   top.postMessage(JSON.parse(JSON.stringify(data)), referrer);
                 }
               },
               registerServiceWorker = function(askPermission, onlyRegister) {
                 if ('serviceWorker' in navigator) {
                   navigator.serviceWorker.register(serviceWorkerUrl).then(function(reg) {
                     // registration worked
                     if(!onlyRegister) {
                       subscribePush(askPermission);
                     }
                   }).catch(function(error) {
                     // failed to register service worker
                     sendMessage();
                   });
                 }
               },
               subscribePush = function(askPermission) {
                 if (Notification.permission !== 'granted' && !askPermission) {
                   sendMessage();
                   return;
                 }
                 if ('serviceWorker' in navigator) {
                   navigator.serviceWorker.ready.then(function(serviceWorkerRegistration) {
                     serviceWorkerRegistration.pushManager.subscribe({userVisibleOnly: true}).then(function(subscription){
                       sendMessage(subscription);
                     }).catch(function(e) {
                       console.log('error: serviceworker subscription failed');
                       sendMessage();
                     });
                   });
                 }
               },
               unsubscribePush = function() {
                 if ('serviceWorker' in navigator) {
                   navigator.serviceWorker.ready.then(function(serviceWorkerRegistration) {
                     // To unsubscribe from push messaging, you need get the
                     // subscription object, which you can call unsubscribe() on.
                     serviceWorkerRegistration.pushManager.getSubscription().then(
                       function(pushSubscription) {
                         // Check we have a subscription to unsubscribe
                         if (!pushSubscription) {
                           // No subscription object, so set the state
                           // to allow the user to subscribe to push
                           sendMessage();
                           return;
                         }
                         // We have a subscription, so call unsubscribe on it
                         pushSubscription.unsubscribe().then(function(successful) {
                           //Unsubscribe successful
                           sendMessage();
                         }).catch(function(e) {
                           // We failed to unsubscribe, this can lead to
                           // an unusual state, so may be best to remove
                           // the users data from your data store and
                           // inform the user that you have done so
                           sendMessage();
                         });
                       }
                     ).catch(function(e) {
                       sendMessage();
                     });
                   });
                 }
               },
               init = function() {
                 initParams();
                 updateUI();
                 if(window.opener) {
                   switch(action) {
                     case "ask:permission":
                       registerServiceWorker(true);
                       break;
                     case "get:subscription":
                       registerServiceWorker();
                       break;
                     default:
                       break;
                   }
                 } else {
                   // send push_frame_loaded event to parent window
                   addMessagingEvents();
                   registerServiceWorker(false, true);
                   top.postMessage(JSON.parse(JSON.stringify({'action': 'push_frame_loaded'})), referrer);
                 }
               };
               currentLocaleTranslationString =function(){
                let webPushTranslations;
                switch(locale) {
                  case 'en-us': {
                   webPushTranslations = {
                    "title":"Freshchat Web Push Notification",
                    "allow":"<p>Click on “<strong>Allow</strong>“ to enable chat notifications</p>",
                    "helpText":"Do not miss any conversations.",
                    "poweredBy":'Powered by <a href="https://www.freshworks.com/live-chat-software/freshchat/" target="_blank" class="red">Freshchat</a>'
                    }
                    break;
                  }
                  case 'ar': {
                  webPushTranslations = {
                    "title":"Freshchat دفع الاخطار على شبكة الإنترنت",
                    "allow":"<p> انقر على “<strong> السماح </ strong>“ لتمكين إشعارات الدردشة </ p>",
                    "helpText":"لا تفوت أي محادثات.",
                    "poweredBy":'مدعوم بواسطة <a href="https://www.freshworks.com/live-chat-software/freshchat/" target="_blank" class="red"> Freshchat </a>'
                    }
                    break;
                  }
                  case 'ca': {
                  webPushTranslations = {
                    "title": "Notificació Push Web Freshchat",
                    "allow": "<p> Feu clic a “<strong>Permet</strong>“ per habilitar les notificacions de xat </p>",
                    "helpText": "No us perdeu cap conversa.",
                    "poweredBy": "Desenvolupat per <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'cs': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push Notification",
                    "allow": "<p> Kliknutím na “<strong>Povolit</strong>“ povolíte oznámení chatu </p>",
                    "helpText": "Nenechte si ujít žádné konverzace.",
                    "poweredBy": "Běží na <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'cy': {
                  webPushTranslations = {
                      "title": "Hysbysiad Gwthio Gwe Freshchat",
                      "allow": "<p> Cliciwch ar “<strong>Caniatáu</strong>” i alluogi hysbysiadau sgwrsio </p>",
                      "helpText": "Peidiwch â cholli unrhyw sgyrsiau.",
                      "poweredBy": "Wedi'i bweru gan <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'da': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push-anmeldelse",
                    "allow": "<p> Klik på “<strong>Tillad</strong>“ for at aktivere chatunderretninger </p>",
                    "helpText": "Gå ikke glip af nogen samtaler.",
                    "poweredBy": "Drives af <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'de': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push Benachrichtigung",
                    "allow": "<p> Klicken Sie auf “<strong>Zulassen</strong>“, um Chat-Benachrichtigungen zu aktivieren </p>",
                    "helpText": "Verpassen Sie keine Gespräche.",
                    "poweredBy": "<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Präsentiert</a> von <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'es-mx':
                  case 'es': {
                  webPushTranslations = {
                    "title": "Notificación push de Freshchat Web",
                    "allow": "<p> Haga clic en “<strong>Permitir</strong>“ para habilitar las notificaciones de chat </p>",
                    "helpText": "No te pierdas ninguna conversación.",
                    "poweredBy": "Desarrollado por <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'et': {
                  webPushTranslations = {
                      "title": "Freshchat veebisurveteade",
                      "allow": "<p> Vestlusteatiste lubamiseks klõpsake “<strong>Luba</strong>“ </p>",
                      "helpText": "Ära jäta ühtegi vestlust vahele.",
                      "poweredBy": "Powered by <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'fi': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push -ilmoitus",
                    "allow": "<p> Napsauta ”<strong>Salli</strong>” ottaaksesi chat-ilmoitukset käyttöön </p>",
                    "helpText": "Älä missaa keskusteluja.",
                    "poweredBy": "Powered by <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'fr': {
                  webPushTranslations = {
                    "title": "Notification Push Web Freshchat",
                    "allow": "<p> Cliquez sur “<strong>Autoriser</strong>“ pour activer les notifications de discussion. </p>",
                    "helpText": "Ne manquez aucune conversation.",
                    "poweredBy": "Propulsé par <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'he': {
                  webPushTranslations = {
                    "title": "הודעה על דחיפת האינטרנט של Freshchat",
                    "allow": "<p style=\";text-align:right;direction:rtl\"> לחץ על “<strong>אפשר</strong>“ כדי לאפשר התראות צ'אט </p>",
                    "helpText": "אל תחמיץ שיחות.",
                    "poweredBy": "מופעל על ידי <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'hu': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push értesítés",
                    "allow": "<p> Kattintson az “<strong>Engedélyezés</strong>” gombra a csevegési értesítések engedélyezéséhez </p>",
                    "helpText": "Ne hagyjon ki egyetlen beszélgetést sem.",
                    "poweredBy": "Powered by <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'id': {
                  return webPushTranslations = {
                    "title": "Pemberitahuan Push Web Freshchat",
                    "allow": "<p> Klik “<strong>Izinkan</strong>“ untuk mengaktifkan notifikasi obrolan </p>",
                    "helpText": "Jangan lewatkan percakapan apa pun.",
                    "poweredBy": "Didukung oleh <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'it': {
                  webPushTranslations = {
                    "title": "Notifica Push Web Freshchat",
                    "allow": "<p> Fai clic su “<strong>Consenti</strong>“ per abilitare le notifiche della chat </p>",
                    "helpText": "Non perdere nessuna conversazione.",
                    "poweredBy": "Realizzato da <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'ja': {
                  webPushTranslations = {
                    "title": "Freshchat Webプッシュ通知",
                    "allow": "<p> “<strong>許可</strong>“ をクリックしてチャット通知を有効にします</p>",
                    "helpText": "会話を見逃さないでください。",
                    "poweredBy": "<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchatを</a>搭載"
                  }
                    break;
                  }
                  case 'ko': {
                  webPushTranslations = {
                    "title": "Freshchat 웹 푸시 알림",
                    "allow": "<p> 채팅 알림을 활성화하려면 “<strong>허용</strong>“ 을 클릭하십시오 </p>",
                    "helpText": "대화를 놓치지 마십시오.",
                    "poweredBy": "<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat에</a> 의해 <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">구동</a>"
                  }
                    break;
                  }
                  case 'lv': {
                  webPushTranslations = {
                      "title": "Freshchat Web Push paziņojums",
                      "allow": "<p> Noklikšķiniet uz “<strong>Atļaut</strong>”, lai iespējotu tērzēšanas paziņojumus </p>",
                      "helpText": "Nepalaidiet garām nevienu sarunu.",
                      "poweredBy": "Darbina <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'nl': {
                    return webPushTranslations = {
                      "title": "Freshchat Web Push-melding",
                      "allow": "<p> Klik op “<strong>Toestaan</strong>“ om chatmeldingen in te schakelen </p>",
                      "helpText": "Mis geen enkele conversatie.",
                      "poweredBy": "Aangedreven door <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'no': {
                  webPushTranslations = {
                    "title": "Freshchat Web Push-varsling",
                    "allow": "<p> Klikk på “<strong>Tillat</strong>“ for å aktivere chatvarsler </p>",
                    "helpText": "Ikke gå glipp av samtaler.",
                    "poweredBy": "Drevet av <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'pl': {
                  webPushTranslations = {
                    "title": "Powiadomienie push w sieci Freshchat",
                    "allow": "<p> Kliknij “<strong>Zezwól</strong>”, aby włączyć powiadomienia czatu </p>",
                    "helpText": "Nie przegap żadnych rozmów.",
                    "poweredBy": "Obsługiwane przez <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'pt-br':
                  case 'pt-pt': {
                   webPushTranslations = {
                    "title": "Notificação por push da Web Freshchat",
                    "allow": "<p> Clique em “<strong>Permitir</strong>“ para ativar as notificações de bate-papo </p>",
                    "helpText": "Não perca nenhuma conversa.",
                    "poweredBy": "Desenvolvido por <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'ru': {
                  webPushTranslations = {
                      "title": "Freshchat Web Push-уведомление",
                      "allow": "<p> Нажмите “<strong>Разрешить</strong>“, чтобы включить уведомления в чате </p>",
                      "helpText": "Не пропустите ни одного разговора.",
                      "poweredBy": "Работает на <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'sk': {
                  webPushTranslations = {
                      "title": "Freshchat Web Push Notification",
                      "allow": "<p> Kliknutím na “<strong>Povoliť</strong>“ povolíte upozornenia na čet </p>",
                      "helpText": "Nenechajte si ujsť žiadne rozhovory.",
                      "poweredBy": "Používa technológiu <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'sl': {
                  webPushTranslations = {
                      "title": "Obvestilo o spletnem potisku Freshchat",
                      "allow": "<p> Kliknite “<strong>Dovoli</strong>“, da omogočite obvestila o klepetu </p>",
                      "helpText": "Ne zamudite nobenih pogovorov.",
                      "poweredBy": "Poganja ga <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'sv': {
                  webPushTranslations = {
                    "title": "Freshchat-meddelande om webbpush",
                    "allow": "<p> Klicka på “<strong>Tillåt</strong>“ för att aktivera chattaviseringar </p>",
                    "helpText": "Missa inga samtal.",
                    "poweredBy": "Drivs av <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'th': {
                    webPushTranslations = {
                    "title": "แจ้งเตือนผลักดันเว็บ Freshchat",
                    "allow": "<p> คลิกที่ “<strong>อนุญาต</strong>“ เพื่อเปิดใช้งานการแจ้งเตือนการแชท </p>",
                    "helpText": "อย่าพลาดการสนทนาใด ๆ",
                    "poweredBy": "ขับเคลื่อนโดย <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                  }
                    break;
                  }
                  case 'tr': {
                    webPushTranslations = {
                      "title": "Freshchat Web Push Bildirimi",
                      "allow": "<p> Sohbet bildirimlerini etkinleştirmek için “<strong>İzin Ver</strong>” seçeneğine tıklayın </p>",
                      "helpText": "Hiçbir konuşmayı kaçırmayın.",
                      "poweredBy": "<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a> tarafından <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">desteklenmektedir</a>"
                    }
                    break;
                  }
                  case 'uk': {
                  webPushTranslations = {
                      "title": "Повідомлення Push через Freshchat",
                      "allow": "<p> Клацніть на “<strong>Дозволити</strong>“, щоб увімкнути сповіщення чату </p>",
                      "helpText": "Не пропускайте жодних розмов.",
                      "poweredBy": "Працює на <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'vi': {
                   webPushTranslations = {
                      "title": "Thông báo đẩy web Freshchat",
                      "allow": "<p> Nhấp vào trên “<strong>Cho phép trên mạng</strong>“ để bật thông báo trò chuyện </p>",
                      "helpText": "Đừng bỏ lỡ bất kỳ cuộc trò chuyện.",
                      "poweredBy": "Cung cấp bởi <a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>"
                    }
                    break;
                  }
                  case 'zh-cn': {
                  webPushTranslations = {
                      "title": "Freshchat Web推送通知",
                      "allow": "<p>单击 “<strong>允许</strong>” 以启用聊天通知</p>",
                      "helpText": "不要错过任何对话。",
                      "poweredBy": "由<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>提供支持"
                    }
                    break;
                  }
                  case 'zh-tw': {
                  webPushTranslations = {
                      "title": "Freshchat Web推送通知",
                      "allow": "<p>單擊 “<strong>允許</strong>” 以啟用聊天通知</p>",
                      "helpText": "不要錯過任何對話。",
                      "poweredBy": "由<a href=\"https://www.freshworks.com/live-chat-software/freshchat/\" target=\"_blank\" class=\"red\">Freshchat</a>提供支持"
                    }
                    break;
                  }
                }
                return webPushTranslations;
               }
           init();
         })();
      </script>
   
</body></html>