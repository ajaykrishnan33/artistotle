<!DOCTYPE html>
<!-- saved from url=(0081)https://soundaryamurugaiyan-org-99621b5473a1e5517110048.freshchat.com/home/152627 -->
<html lang="en-us" class="fc-widget-normal multi-widget-ui"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Freshchat</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <!--<base href="/">--><base href=".">
<meta name="hotline-web/config/environment" content="%7B%22ember-cli-mirage%22%3A%7B%22enabled%22%3Afalse%2C%22usingProxy%22%3Afalse%2C%22useDefaultPassthroughs%22%3Atrue%7D%2C%22modulePrefix%22%3A%22hotline-web%22%2C%22environment%22%3A%22production%22%2C%22baseURL%22%3A%22%2F%22%2C%22rootURL%22%3A%22%22%2C%22locationType%22%3A%22auto%22%2C%22EmberENV%22%3A%7B%22cdnUrl%22%3A%22https%3A%2F%2Fassetscdn-wchat.in.freshchat.com%2Fstatic%2F%22%2C%22FEATURES%22%3A%7B%7D%2C%22EXTEND_PROTOTYPES%22%3A%7B%22Date%22%3Afalse%7D%2C%22cdnEnabled%22%3Atrue%2C%22_APPLICATION_TEMPLATE_WRAPPER%22%3Afalse%2C%22_DEFAULT_ASYNC_OBSERVERS%22%3Atrue%2C%22_JQUERY_INTEGRATION%22%3Afalse%2C%22_TEMPLATE_ONLY_GLIMMER_COMPONENTS%22%3Atrue%7D%2C%22APP%22%3A%7B%22name%22%3A%22hotline-web%22%2C%22version%22%3A%22FCH24.05.2%2Bc37ee2e7%22%7D%2C%22contentSecurityPolicy%22%3A%7B%22style-src%22%3A%22&#39;unsafe-inline&#39;%20*%22%2C%22font-src%22%3A%22&#39;self&#39;%20*%20data%3A%22%2C%22img-src%22%3A%22&#39;self&#39;%20*%20data%3A%22%2C%22connect-src%22%3A%22&#39;self&#39;%20*%22%2C%22script-src%22%3A%22&#39;self&#39;%20&#39;unsafe-eval&#39;%20&#39;unsafe-inline&#39;%20https%3A%2F%2Fassetscdn-wchat.in.freshchat.com%20https%3A%2F%2F*.freshchat.com%20https%3A%2F%2F*.freshpori.com%20https%3A%2F%2Frts-static-prod.freshworksapi.com%2Find%2Frts-min.js%22%2C%22child-src%22%3A%22&#39;self&#39;%20*%20blob%3A%22%2C%22media-src%22%3A%22&#39;self&#39;%20https%3A%2F%2F*.freshchat.com%20https%3A%2F%2F*.freshpori.com%22%2C%22manifest-src%22%3A%22&#39;self&#39;%20https%3A%2F%2F*.freshchat.com%20https%3A%2F%2F*.freshpori.com%22%2C%22default-src%22%3A%5B%22&#39;none&#39;%22%5D%7D%2C%22contentSecurityPolicyHeader%22%3A%22Content-Security-Policy%22%2C%22contentSecurityPolicyMeta%22%3Atrue%2C%22outputPath%22%3A%22static%22%2C%22socket%22%3A%7B%22domain%22%3A%7B%22production%22%3A%22rts-in-fcht.freshworksapi.com%22%7D%2C%22protocol%22%3A%22https%3A%2F%2F%22%2C%22subDelay%22%3A15000%2C%22reconnectDelay%22%3A10%7D%2C%22webpush%22%3A%7B%22domain%22%3A%7B%22production%22%3A%22%7BappName%7D.webpush.in.freshchat.com%22%2C%22crm%22%3A%7B%22production%22%3A%22%7BappName%7D.wchat.in.webpush.myfreshworks.com%22%7D%7D%2C%22protocol%22%3A%22https%3A%2F%2F%22%7D%2C%22hotlineEnv%22%3A%7B%22type%22%3A%22production%22%7D%2C%22cdn%22%3A%7B%22enabled%22%3A%7B%22forAssets%22%3Atrue%2C%22forApi%22%3Atrue%7D%2C%22assets%22%3A%22assetscdn-%22%2C%22api%22%3A%22apicdn-%22%2C%22domain%22%3A%7B%22production%22%3A%22.in.freshchat.com%2F%7BdeploymentPath%7D%22%7D%2C%22subDomain%22%3A%22wchat%22%2C%22protocol%22%3A%22https%3A%2F%2F%22%7D%2C%22rtsCdnUrl%22%3A%7B%22production%22%3A%22https%3A%2F%2Frts-static-prod.freshworksapi.com%2Find%2Frts-min.js%22%7D%2C%22helpWidgetCdnUrl%22%3A%22https%3A%2F%2Fassetscdn-wchat.in.freshchat.com%2Fhelp-widget%2Faps1-00%22%2C%22exportApplicationGlobal%22%3Afalse%7D">
<meta http-equiv="Content-Security-Policy" content="style-src &#39;unsafe-inline&#39; *; font-src &#39;self&#39; * data:; img-src &#39;self&#39; * data:; connect-src &#39;self&#39; *; script-src &#39;self&#39; &#39;unsafe-eval&#39; &#39;unsafe-inline&#39; https://assetscdn-wchat.in.freshchat.com https://*.freshchat.com https://*.freshpori.com https://rts-static-prod.freshworksapi.com/ind/rts-min.js; child-src &#39;self&#39; * blob:; media-src &#39;self&#39; https://*.freshchat.com https://*.freshpori.com; manifest-src &#39;self&#39; https://*.freshchat.com https://*.freshpori.com; default-src &#39;none&#39;; ">

    
<link href="./vendor.d64d219ca4493f67a3970efc52d51c86.css" rel="stylesheet">

    
<link href="./hotline-web.d41d8cd98f00b204e9800998ecf8427e.css" rel="stylesheet">


    
  <script type="text/javascript" src="chrome-extension://mdnleldcmiljblolnjhpnblkcekpdkpa/libs/customElements.js" class="__REQUESTLY__SCRIPT"></script><script type="text/javascript" class="__REQUESTLY__SCRIPT">((namespace) => {
  const RuleSourceKey = {
    URL: "Url",
    HOST: "host",
    PATH: "path",
  };

  const RuleSourceOperator = {
    EQUALS: "Equals",
    CONTAINS: "Contains",
    MATCHES: "Matches",
    WILDCARD_MATCHES: "Wildcard_Matches",
  };

  const toRegex = (regexStr) => {
    const matchRegExp = regexStr.match(new RegExp("^/(.+)/(|i|g|ig|gi)$"));

    if (!matchRegExp) {
      return null;
    }

    try {
      return new RegExp(matchRegExp[1], matchRegExp[2]);
    } catch {
      return null;
    }
  };

  const checkRegexMatch = (regexString, inputString) => {
    if (!regexString.startsWith("/")) {
      regexString = `/${regexString}/`; // Keeping enclosing slashes for regex as optional
    }

    const regex = toRegex(regexString);
    return regex?.test(inputString);
  };

  const checkWildCardMatch = (wildCardString, inputString) => {
    const regexString = "/^" + wildCardString.replaceAll("*", ".*") + "$/";
    return checkRegexMatch(regexString, inputString);
  };

  const extractUrlComponent = (url, key) => {
    const urlObj = new URL(url);

    switch (key) {
      case RuleSourceKey.URL:
        return url;
      case RuleSourceKey.HOST:
        return urlObj.host;
      case RuleSourceKey.PATH:
        return urlObj.pathname;
    }
  };

  window[namespace] = window[namespace] || {};
  window[namespace].matchSourceUrl = (sourceObject, url) => {
    const urlComponent = extractUrlComponent(url, sourceObject.key);
    const value = sourceObject.value;

    if (!urlComponent) {
      return false;
    }

    switch (sourceObject.operator) {
      case RuleSourceOperator.EQUALS:
        if (value === urlComponent) {
          return true;
        }
        break;

      case RuleSourceOperator.CONTAINS:
        if (urlComponent.indexOf(value) !== -1) {
          return true;
        }
        break;

      case RuleSourceOperator.MATCHES: {
        return checkRegexMatch(value, urlComponent);
      }

      case RuleSourceOperator.WILDCARD_MATCHES: {
        return checkWildCardMatch(value, urlComponent);
      }
    }

    return false;
  };
})('__REQUESTLY__')</script><script type="text/javascript" class="__REQUESTLY__SCRIPT">(function ({
  namespace,
  customHeaderPrefix = "",
  ignoredHeadersOnRedirect = [],
}) {
  window[namespace] = window[namespace] || {};
  window[namespace].requestRules = [];
  window[namespace].responseRules = [];
  window[namespace].redirectRules = [];
  window[namespace].replaceRules = [];
  let isDebugMode = false;

  // Some frames are sandboxes and throw DOMException when accessing localStorage
  try {
    isDebugMode = window && window.localStorage && localStorage.isDebugMode;
  } catch (e) {}

  const isExtensionEnabled = () => {
    return window[namespace].isExtensionEnabled ?? true;
  };

  const getAbsoluteUrl = (url) => {
    const dummyLink = document.createElement("a");
    dummyLink.href = url;
    return dummyLink.href;
  };

  const isNonJsonObject = (obj) => {
    return [
      Blob,
      ArrayBuffer,
      Object.getPrototypeOf(Uint8Array), // TypedArray instance type
      DataView,
      FormData,
      URLSearchParams,
    ].some((nonJsonType) => obj instanceof nonJsonType);
  };

  /**
   * @param {Object} json
   * @param {String} path -> "a", "a.b", "a.0.b (If a is an array containing list of objects"
   * Also copied in shared/utils.js for the sake of testing
   */
  const traverseJsonByPath = (jsonObject, path) => {
    if (!path) return;

    const pathParts = path.split(".");

    try {
      // Reach the last node but not the leaf node.
      for (i = 0; i < pathParts.length - 1; i++) {
        jsonObject = jsonObject[pathParts[i]];
      }

      return jsonObject[pathParts[pathParts.length - 1]];
    } catch (e) {
      /* Do nothing */
    }
  };

  const matchesSourceFilters = ({ requestData, method }, sourceFilters) => {
    const sourceFiltersArray = Array.isArray(sourceFilters) ? sourceFilters : [sourceFilters];

    return (
      !sourceFiltersArray.length ||
      sourceFiltersArray.some((sourceFilter) => {
        if (sourceFilter?.requestMethod?.length && !sourceFilter.requestMethod.includes(method)) {
          return false;
        }

        let requestPayloadFilter = sourceFilter?.requestPayload;

        if (!requestPayloadFilter) return true;
        if (typeof requestPayloadFilter === "object" && Object.keys(requestPayloadFilter).length === 0) return true;

        // We only allow request payload targeting when requestData is JSON
        if (!requestData || typeof requestData !== "object") return false;
        if (Object.keys(requestData).length === 0) return false;

        requestPayloadFilter = requestPayloadFilter || {};
        const targetedKey = requestPayloadFilter?.key;
        const targetedValue = requestPayloadFilter?.value;

        // tagetedKey is the json path e.g. a.b.0.c
        if (targetedKey && typeof targetedValue !== undefined) {
          const valueInRequestData = traverseJsonByPath(requestData, targetedKey);
          const operator = requestPayloadFilter?.operator;

          if (!operator || operator === "Equals") {
            return valueInRequestData === targetedValue;
          }

          if (operator === "Contains") {
            return valueInRequestData.includes(targetedValue);
          }
        }

        return false;
      })
    );
  };

  const matchRuleSource = ({ url, requestData, method }, rule) => {
    const modification = rule.pairs[0];
    const ruleSource = modification.source;

    return (
      window[namespace].matchSourceUrl(ruleSource, url) &&
      matchesSourceFilters({ requestData, method }, ruleSource?.filters)
    );
  };

  const getRequestRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].requestRules?.findLast((rule) =>
      window[namespace].matchSourceUrl(rule.pairs[0].source, url)
    );
  };

  const getResponseRule = ({ url, requestData, method }) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].responseRules?.findLast((rule) => {
      return matchRuleSource({ url, requestData, method }, rule);
    });
  };

  const getMatchingRedirectRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].redirectRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const getMatchingReplaceRule = (url) => {
    if (!isExtensionEnabled()) {
      return null;
    }

    return window[namespace].replaceRules?.findLast((rule) =>
      rule.pairs.some((pair) => window[namespace].matchSourceUrl(pair.source, url))
    );
  };

  const shouldServeResponseWithoutRequest = (responseRule) => {
    const responseModification = responseRule.pairs[0].response;
    return responseModification.type === "static" && responseModification.serveWithoutRequest;
  };

  const getFunctionFromCode = (code) => {
    return new Function("args", `return (${code})(args);`);
  };

  const getCustomRequestBody = (requestRule, args) => {
    const modification = requestRule.pairs[0].request;
    if (modification.type === "static") {
      requestBody = modification.value;
    } else {
      requestBody = getFunctionFromCode(modification.value)(args);
    }

    if (typeof requestBody !== "object" || isNonJsonObject(requestBody)) {
      return requestBody;
    }

    return JSON.stringify(requestBody);
  };

  /**
   * @param mightBeJSONString string which might be JSON String or normal String
   * @param doStrictCheck should return empty JSON if invalid JSON string
   */
  const jsonifyValidJSONString = (mightBeJSONString, doStrictCheck) => {
    const defaultValue = doStrictCheck ? {} : mightBeJSONString;

    if (typeof mightBeJSONString !== "string") {
      return defaultValue;
    }

    try {
      return JSON.parse(mightBeJSONString);
    } catch (e) {
      /* Do Nothing. Unable to parse the param value */
    }

    return defaultValue;
  };

  const isJSON = (data) => {
    const parsedJson = jsonifyValidJSONString(data);
    return parsedJson !== data; // if data is not a JSON, jsonifyValidJSONString() returns same value
  };

  const notifyRequestRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "request_rule_applied",
        id: message.ruleDetails.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const notifyResponseRuleApplied = (message) => {
    window.postMessage(
      {
        from: "requestly",
        type: "response_rule_applied",
        id: message.rule.id,
        requestDetails: message["requestDetails"],
      },
      window.location.href
    );
  };

  const isPromise = (obj) =>
    !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";

  const isContentTypeJSON = (contentType) => !!contentType?.includes("application/json");

  // XHR Implementation
  const updateXhrReadyState = (xhr, readyState) => {
    Object.defineProperty(xhr, "readyState", { writable: true });
    xhr.readyState = readyState;
    xhr.dispatchEvent(new CustomEvent("readystatechange"));
  };

  const resolveXHR = (xhr, responseData) => {
    xhr.dispatchEvent(new ProgressEvent("loadstart"));

    // update response headers
    const contentType = isJSON(responseData) ? "application/json" : "text/plain";
    xhr.getResponseHeader = (key) => {
      if (key.toLowerCase() === "content-type") {
        return contentType;
      }
      return null;
    };
    updateXhrReadyState(xhr, xhr.HEADERS_RECEIVED);
    updateXhrReadyState(xhr, xhr.LOADING);

    // mark resolved
    updateXhrReadyState(xhr, xhr.DONE);
  };

  const OriginalXMLHttpRequest = XMLHttpRequest;

  const createProxyXHRObject = function () {
    const actualXhr = this;

    const dispatchEventToActualXHR = (type, e) => {
      isDebugMode && console.log("[RQ]", `on${type}`, e);
      actualXhr.dispatchEvent(
        new ProgressEvent(type, {
          lengthComputable: e?.lengthComputable,
          loaded: e?.loaded,
          total: e?.total,
        })
      );
    };

    const updateActualXHRReadyState = (readyState) => {
      updateXhrReadyState(actualXhr, readyState);
    };

    const onReadyStateChange = async function () {
      isDebugMode &&
        console.log("[RQ]", "onReadyStateChange", {
          state: this.readyState,
          status: this.status,
          response: this.response,
          xhr: this,
          url: this._requestURL,
        });
      if (!this.responseRule) {
        return;
      }
      const responseModification = this.responseRule.pairs[0].response;

      if (this.readyState === this.HEADERS_RECEIVED) {
        // For network failures, responseStatus=0 but we still return customResponse with status=200
        const responseStatus = parseInt(responseModification.statusCode || this.status) || 200;
        const responseStatusText = responseModification.statusText || this.statusText;

        Object.defineProperties(actualXhr, {
          status: {
            get: () => responseStatus,
          },
          statusText: {
            get: () => responseStatusText,
          },
          getResponseHeader: {
            value: this.getResponseHeader.bind(this),
          },
          getAllResponseHeaders: {
            value: this.getAllResponseHeaders.bind(this),
          },
        });

        updateActualXHRReadyState(this.HEADERS_RECEIVED);
      } else if (this.readyState === this.DONE) {
        const responseType = this.responseType;
        const contentType = this.getResponseHeader("content-type");

        let customResponse =
          responseModification.type === "code"
            ? getFunctionFromCode(responseModification.value)({
                method: this._method,
                url: this._requestURL,
                requestHeaders: this._requestHeaders,
                requestData: jsonifyValidJSONString(this._requestData),
                responseType: contentType,
                response: this.response,
                responseJSON: jsonifyValidJSONString(this.response, true),
              })
            : responseModification.value;

        // Convert customResponse back to rawText
        // response.value is String and evaluator method might return string/object
        if (isPromise(customResponse)) {
          customResponse = await customResponse;
        }

        isDebugMode &&
          console.log("[RQ]", "Rule Applied - customResponse", { customResponse, responseType, contentType });

        const isUnsupportedResponseType = responseType && !["json", "text"].includes(responseType);

        // We do not support statically modifying responses of type - blob, arraybuffer, document etc.
        if (responseModification.type === "static" && isUnsupportedResponseType) {
          customResponse = this.response;
        }

        if (
          !isUnsupportedResponseType &&
          typeof customResponse === "object" &&
          !(customResponse instanceof Blob) &&
          (responseType === "json" || isContentTypeJSON(contentType))
        ) {
          customResponse = JSON.stringify(customResponse);
        }
        Object.defineProperty(actualXhr, "response", {
          get: function () {
            if (responseModification.type === "static" && responseType === "json") {
              if (typeof customResponse === "object") {
                return customResponse;
              }

              return jsonifyValidJSONString(customResponse);
            }

            return customResponse;
          },
        });

        if (responseType === "" || responseType === "text") {
          Object.defineProperty(actualXhr, "responseText", {
            get: function () {
              return customResponse;
            },
          });
        }

        const responseURL = this.responseURL;
        const responseXML = this.responseXML;

        Object.defineProperties(actualXhr, {
          responseType: {
            get: function () {
              return responseType;
            },
          },
          responseURL: {
            get: function () {
              return responseURL;
            },
          },
          responseXML: {
            get: function () {
              return responseXML;
            },
          },
        });

        const requestDetails = {
          url: this._requestURL,
          method: this._method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        };

        // mark resolved)
        if (this._abort) {
          // Note: This might get delayed due to async in code block
          dispatchEventToActualXHR("abort");
          dispatchEventToActualXHR("loadend");
        } else {
          updateActualXHRReadyState(this.DONE);
          dispatchEventToActualXHR("load");
          dispatchEventToActualXHR("loadend");
        }

        notifyResponseRuleApplied({
          rule: this.responseRule,
          requestDetails,
        });
      } else {
        updateActualXHRReadyState(this.readyState);
      }
    };

    const xhr = new OriginalXMLHttpRequest();
    xhr.addEventListener("readystatechange", onReadyStateChange.bind(xhr), false);
    xhr.addEventListener("abort", dispatchEventToActualXHR.bind(xhr, "abort"), false);
    xhr.addEventListener("error", dispatchEventToActualXHR.bind(xhr, "error"), false);
    xhr.addEventListener("timeout", dispatchEventToActualXHR.bind(xhr, "timeout"), false);
    xhr.addEventListener("loadstart", dispatchEventToActualXHR.bind(xhr, "loadstart"), false);
    xhr.addEventListener("progress", dispatchEventToActualXHR.bind(xhr, "progress"), false);

    const descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "timeout");

    Object.defineProperty(actualXhr, "timeout", {
      get: function () {
        return descriptor.get.call(this);
      },
      set: function (value) {
        xhr.timeout = value;
        descriptor.set.call(this, value);
      },
    });

    this.rqProxyXhr = xhr;
  };

  XMLHttpRequest = function () {
    const xhr = new OriginalXMLHttpRequest();
    createProxyXHRObject.call(xhr);
    return xhr;
  };

  XMLHttpRequest.prototype = OriginalXMLHttpRequest.prototype;
  Object.entries(OriginalXMLHttpRequest).map(([key, val]) => {
    XMLHttpRequest[key] = val;
  });

  const open = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function (method, url) {
    this.rqProxyXhr._method = method;
    this.rqProxyXhr._requestURL = getAbsoluteUrl(url);
    open.apply(this.rqProxyXhr, arguments);
    open.apply(this, arguments);
  };

  const abort = XMLHttpRequest.prototype.abort;
  XMLHttpRequest.prototype.abort = function () {
    isDebugMode && console.log("abort called");
    this.rqProxyXhr._abort = true;
    abort.apply(this, arguments);
    abort.apply(this.rqProxyXhr, arguments);
  };

  let setRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
  XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
    this.rqProxyXhr._requestHeaders = this.rqProxyXhr._requestHeaders || {};
    this.rqProxyXhr._requestHeaders[header] = value;
    setRequestHeader.apply(this.rqProxyXhr, arguments);
    setRequestHeader.apply(this, arguments);
  };

  const send = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function (data) {
    this.rqProxyXhr._requestData = data;

    const requestRule = getRequestRule(this.rqProxyXhr._requestURL);
    if (requestRule) {
      this.rqProxyXhr._requestData = getCustomRequestBody(requestRule, {
        method: this.rqProxyXhr._method,
        url: this.rqProxyXhr._requestURL,
        body: data,
        bodyAsJson: jsonifyValidJSONString(data, true),
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url: this.rqProxyXhr._requestURL,
          method: this.rqProxyXhr._method,
          type: "xmlhttprequest",
          timeStamp: Date.now(),
        },
      });
    }

    this.responseRule = getResponseRule({
      url: this.rqProxyXhr._requestURL,
      requestData: jsonifyValidJSONString(this.rqProxyXhr._requestData),
      method: this.rqProxyXhr._method,
    });
    this.rqProxyXhr.responseRule = this.responseRule;

    const redirectRuleThatMatchesURL = getMatchingRedirectRule(this.rqProxyXhr._requestURL);
    const replaceRuleThatMatchesURL = getMatchingReplaceRule(this.rqProxyXhr._requestURL);
    if (redirectRuleThatMatchesURL || replaceRuleThatMatchesURL) {
      ignoredHeadersOnRedirect.forEach((header) => {
        // Stores ignored header to be set on redirected URL. Refer: https://github.com/requestly/requestly/issues/1208
        const originalHeaderValue =
          this.rqProxyXhr._requestHeaders?.[header] || this.rqProxyXhr._requestHeaders?.[header.toLowerCase()];
        if (isExtensionEnabled() && originalHeaderValue) {
          this.setRequestHeader(customHeaderPrefix + header, originalHeaderValue);
        }
      });
    }

    if (this.responseRule) {
      isDebugMode && console.log("[RQ]", "send and response rule matched", this.responseRule);
      if (shouldServeResponseWithoutRequest(this.responseRule)) {
        isDebugMode && console.log("[RQ]", "send and response rule matched and serveWithoutRequest is true");
        resolveXHR(this.rqProxyXhr, this.responseRule.pairs[0].response.value);
      } else {
        send.call(this.rqProxyXhr, this.rqProxyXhr._requestData);
      }
      return;
    }

    send.call(this, this.rqProxyXhr._requestData);
  };

  // Intercept fetch API
  const _fetch = fetch;
  fetch = async (...args) => {
    const [resource, initOptions = {}] = args;
    const getOriginalResponse = () => _fetch(...args);

    let request;

    if (resource instanceof Request) {
      request = resource.clone();
    } else {
      request = new Request(resource.toString(), initOptions);
    }

    let hasModifiedHeaders = false;

    const url = getAbsoluteUrl(request.url);
    const method = request.method;

    const redirectRuleThatMatchesURL = getMatchingRedirectRule(url);
    const replaceRuleThatMatchesURL = getMatchingReplaceRule(url);

    // redirect/replace rule specific code that is applied only when redirect/replace rule matches the URL
    if (redirectRuleThatMatchesURL || replaceRuleThatMatchesURL) {
      // Stores Auth header to be set on redirected URL. Refer: https://github.com/requestly/requestly/issues/1208
      ignoredHeadersOnRedirect.forEach((header) => {
        const originalHeaderValue = request.headers.get(header);
        if (isExtensionEnabled() && originalHeaderValue) {
          hasModifiedHeaders = true;
          request.headers.set(customHeaderPrefix + header, originalHeaderValue);
        }
      });
    }

    // Request body can be sent only for request methods other than GET and HEAD.
    const canRequestBodyBeSent = !["GET", "HEAD"].includes(method);

    const requestRule = canRequestBodyBeSent && getRequestRule(url);
    if (requestRule) {
      const originalRequestBody = await request.text();
      const requestBody =
        getCustomRequestBody(requestRule, {
          method: request.method,
          url,
          body: originalRequestBody,
          bodyAsJson: jsonifyValidJSONString(originalRequestBody, true),
        }) || {};

      request = new Request(request.url, {
        method,
        body: requestBody,
        headers: request.headers,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
      });

      notifyRequestRuleApplied({
        ruleDetails: requestRule,
        requestDetails: {
          url,
          method: request.method,
          type: "fetch",
          timeStamp: Date.now(),
        },
      });
    }

    let requestData;
    if (canRequestBodyBeSent) {
      requestData = jsonifyValidJSONString(await request.clone().text()); // cloning because the request will be used to make API call
    }

    const responseRule = getResponseRule({ url, requestData, method });
    let responseHeaders;
    let fetchedResponse;

    if (responseRule && shouldServeResponseWithoutRequest(responseRule)) {
      const contentType = isJSON(responseRule.pairs[0].response.value) ? "application/json" : "text/plain";
      responseHeaders = new Headers({ "content-type": contentType });
    } else {
      try {
        if (requestRule || hasModifiedHeaders) {
          // use modified request to fetch response
          fetchedResponse = await _fetch(request);
        } else {
          fetchedResponse = await getOriginalResponse();
        }

        if (!responseRule) {
          return fetchedResponse;
        }

        responseHeaders = fetchedResponse?.headers;
      } catch (error) {
        if (!responseRule) {
          return Promise.reject(error);
        }
      }
    }

    isDebugMode &&
      console.log("RQ", "Inside the fetch block for url", {
        url,
        resource,
        initOptions,
        fetchedResponse,
      });

    let customResponse;
    const responseModification = responseRule.pairs[0].response;

    if (responseModification.type === "code") {
      const requestHeaders =
        request.headers &&
        Array.from(request.headers).reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {});

      let evaluatorArgs = {
        method,
        url,
        requestHeaders,
        requestData,
      };

      if (fetchedResponse) {
        const fetchedResponseData = await fetchedResponse.text();
        const responseType = fetchedResponse.headers.get("content-type");
        const fetchedResponseDataAsJson = jsonifyValidJSONString(fetchedResponseData, true);

        evaluatorArgs = {
          ...evaluatorArgs,
          responseType,
          response: fetchedResponseData,
          responseJSON: fetchedResponseDataAsJson,
        };
      }

      customResponse = getFunctionFromCode(responseModification.value)(evaluatorArgs);

      // evaluator might return us Object but response.value is string
      // So make the response consistent by converting to JSON String and then create the Response object
      if (isPromise(customResponse)) {
        customResponse = await customResponse;
      }

      if (typeof customResponse === "object" && isContentTypeJSON(evaluatorArgs?.responseType)) {
        customResponse = JSON.stringify(customResponse);
      }
    } else {
      customResponse = responseModification.value;
    }

    const requestDetails = {
      url,
      method,
      type: "fetch",
      timeStamp: Date.now(),
    };

    notifyResponseRuleApplied({
      rule: responseRule,
      requestDetails,
    });

    // For network failures, fetchedResponse is undefined but we still return customResponse with status=200
    const finalStatusCode = parseInt(responseModification.statusCode || fetchedResponse?.status) || 200;
    const requiresNullResponseBody = [204, 205, 304].includes(finalStatusCode);

    return new Response(requiresNullResponseBody ? null : new Blob([customResponse]), {
      status: finalStatusCode,
      statusText: responseModification.statusText || fetchedResponse?.statusText,
      headers: responseHeaders,
    });
  };
})({"namespace":"__REQUESTLY__","customHeaderPrefix":"x-rq-","ignoredHeadersOnRedirect":["Authorization"]})</script><script src="./rts-min.js"></script><link rel="stylesheet" type="text/css" href="./2244.css"></head>
  <body class="webchat ember-application" dir="ltr">
    

    
<script src="./vendor.657f3dcde82ee7607bed5b4ac7579bb9.js"></script>

    
<script src="./2556.js"></script>
<link href="./chunk.b6225a2f62108f60dec0.css" rel="stylesheet">
<link href="./fd-messaging.9711269ec0f6c1edd5fa.css" rel="stylesheet">
<script src="./fd-messaging.38e399b330a298ac658f.js"></script>


    <div id="ember-basic-dropdown-wormhole"></div>
  

<!---->  <div aria-live="polite" id="ember3" class="content-vp ember-view"><!----><div class="hotline-launcher     " tabindex="-1">
  <div class="viewport h-chat-custom ">
    <div class="widget-status animated fadeInUp faster" aria-live="polite">
      <div class="help-text  dn">
<!----></div>

    </div>
    <div id="ember14" class="h-conv ember-view"><div class="fc-conversation-view">
  <div class="h-header  single-channel-header single-channel-no-desc">
    <div class="title fadeIn solid">
        <div class="logo">
            <img class="animated zoomIn faster" src="./freshchat-line.7327fc2a43ff6a857c38e96ffa7e00f2.svg" alt="Freshchat">
        </div>
      <div class="channel-info animated fadeIn faster  channel-info-width">
        <h1 class="channel-title
        no-desc
        ">
          Chat with us
        </h1>
<!----><!---->      </div>
<!---->    </div>
  </div>
  <div class="body
    no-articles single-channel-section single-channel-no-desc">
<!---->    <div class="h-chat-window ">
      <div class="cal-picker-maximized hide-cal-picker">
        <div id="ember15" class="maximized-slots ember-view"><div class="cal-picker-nav">
  <span class="cal-nav-left">
    <i class="ic-cal-back clickable icon-ic_back_calendar" role="button" tabindex="0" aria-label="Minimize calendar picker" data-ember-action="" data-ember-action-16="16"></i>
  </span>
  <span class="cal-picker-title">
    Schedule a meeting
  </span>
  <span class="cal-meeting-length">
    
  </span>
</div>
<div class="cal-timings-scroll">
  <div id="ember17" class="ember-view"><!----></div>
</div></div>
      </div>
      <div class="expand">
<!----><!---->      </div>
<!---->      <div class="h-conv-chat h-theme-bg-1 animated fadeInUp speed scroll-section  no-profile " tabindex="0" role="status" aria-live="assertive" aria-relevant="additions" aria-atomic="false">
        <ul id="ember18" class="fc-app-conversation-message ember-view"><!---->
  <li id="ember19" class="fc-ui-message message-container grp-ended grp-started agent-msg ember-view"><!---->
<!---->
  <div class="h-chat  ">
          <div class="agent-pic " aria-hidden="true">
            <span class="avatar-content-wrap">
              <span class="theme-bg theme-1">
                <span class="avatar-content">A</span>
              </span>
            </span>
                    </div>
          <span class="time">
<!---->          </span>
    <div class="h-conv multiple">
        <div class="agent-name">Artistotle</div>
        <div id="ember20" class="ember-view">  <div class="h-comment    ">
<!---->
            <div id="ember21" class="fc-ui-unity-message-bubble ember-view">  <div class="h-message-text ">Hello there! Need help? Reach out to us right here, and we'll get back to you as soon as we can!</div>
<!----></div>

     
  </div>
<!----></div>

<!----><!---->
<!---->    </div>
  </div>
<!----><!----></li>

<!----><!----><!----><!----><!----><!----><!----><!----></ul>
      </div>
    </div>
    <!---->
      <div class="h-reply-wrapper ">
        <div class="h-reply ">
<!----><!----><!---->              <!---->

                <div data-placeholder="Reply here..." placeholder="Reply here..." data-test-id="ui-editor" aria-label="Type here to reply and please press enter to send the message" tabindex="0" id="app-conversation-editor" class="editable ce-textarea emoji editor-placeholder desktop-browser ember-view" contenteditable="true"><p><br></p></div>
<!---->              

                    <input accept="file" id="fileUploadInput" class="ember-text-field ember-view" type="file">
                  <a href="https://soundaryamurugaiyan-org-99621b5473a1e5517110048.freshchat.com/#" class="h-reply-attach
                        test-class" role="button" aria-label="File attachment" data-ember-action="" data-ember-action-24="24">
                    <i class="icons icon-ic_attachment"></i>
                  </a>
                      
                      <div id="ember26" class="ember-view ember-basic-dropdown-trigger
      
      
      
       h-reply-smiley " role="button" tabindex="0" data-ebd-id="ember25-trigger" aria-owns="ember-basic-dropdown-content-ember25" aria-expanded="false">
    
                      <div class="emoji-pic " aria-label="Emoji picker" data-ember-action="" data-ember-action-27="27">
                        <i class="icons icon-ic_smiley"></i>
                      </div>
                    
  </div>

                      <div id="ember-basic-dropdown-content-ember25" class="ember-basic-dropdown-content-placeholder" style="display: none;"></div>

                  

<!---->        </div>
<!---->      </div>
<!----><!---->  </div>
  <span aria-live="assertive" class="aria-live-region"></span>
</div>
</div>
  </div>
<!----></div>

<!---->
<div class="d-hotline h-btn animated zoomIn faster eager-load  dn  " tabindex="0" role="button" data-ember-action="" data-ember-action-4="4">
      <div id="chat-icon"></div>
    <div class=" ">
      <span aria-hidden="true">
        
      </span>
    </div>
</div>
<style type="text/css">

  

  html, body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Segoe UI Emoji', 'Roboto', 'Oxygen', 'Ubuntu', 'Fira Sans', 'Droid Sans', 'Cantarell', 'Helvetica Neue', sans-serif !important;
  }
  .h-chat-custom .odd .h-conv .h-comment,
  .h-chat-custom .h-channel .h-header,
  .h-chat-custom .h-channel .dummy-bar,
  .h-chat-custom .h-conv .h-header,
  .h-chat-custom .odd .h-conv .h-comment,
  .h-chat-custom .h-conv div.body div.message-container.odd span.chat-msg,
  .iframe-modal .h-modal-notes .modal-header,
  .h-chat-custom .odd .h-conv .h-comment.file-attached .h-message-text,
  .h-chat-custom .odd .h-conv .h-comment.media-message .h-message-text {
    background-color: #25C16F !important;
  }

  .h-chat-custom .odd .h-conv .h-comment .h-message-text a,
  .hotline-launcher.h-open .viewport .h-conv .faq-content .h-header.article-view-header .category-title .sub-title {
    color: #FFFFFF !important;
  }

  .h-chat-custom .h-channel .h-header {
    border: 0.1px solid #25C16F !important;
  }

  .h-chat-custom .h-channel .h-header .icon, .h-chat-custom .h-conv .h-header .icon,
  .h-chat-custom .h-channel .h-header .conv-title, .h-chat-custom .h-conv .h-header .conv-title,
  .h-chat-custom .h-channel .h-header .ic-back, .h-chat-custom .h-conv .h-header .ic-back,
  .h-chat-custom .h-channel .h-header .title, .h-chat-custom .h-conv .h-header .title,
  .h-chat-custom .odd .h-conv .h-comment,
  .h-chat-custom .h-conv div.body div.message-container.odd span.chat-msg,
  .iframe-modal .h-modal-notes .modal-header .frame-title,
  .iframe-modal .h-modal-notes .modal-header .h-close i,
  .preview-bubble {
    color: #FFFFFF !important;
  }

  .h-chat-custom .h-conv div.body div.message-container.odd span.arrow.right {
    border-left-color: #25C16F !important;
  }

  .h-chat-custom div.h-conv div.body div.h-conv-chat {
    background-image: url("https://assetscdn-wchat.in.freshchat.com/static/assets/texture_background_1.aff96620ed7b5dfc8fbadb616251a75a.png") !important;
  }
  .preview-wrapper .top-border{
    border-top: 4px solid #25C16F;
  }

  .reply-options .reply-option-button,
  .h-reply-wrapper .h-reply-button .h-img-button,
  .actions-button-dropdown .h-img-button,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .fc-carousel-wrapper .h-img-button,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .button-region .h-img-button,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .fc-carousel-cards .h-img-button,
  .hotline-launcher.h-open .viewport .h-channel .home-content .body.sections .card-layout .start-new-conversation button.h-img-button,
  .hotline-launcher.h-open .viewport .h-conv .start-new-conversation button.h-img-button,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .fc-carousel-wrapper .fc-multi-select .button-region .h-img-button {
    border: 1px solid #25C16F;
  }

  .reply-options .reply-option-button:hover,
  .h-reply-wrapper .h-reply-button .h-img-button:hover:not([disabled]),
  .h-reply-wrapper .h-reply-button .h-img-button--selected,
  .actions-button-dropdown .h-img-button:hover:not([disabled]),
  .hotline-launcher.h-open .viewport .h-channel .home-content .body.sections .card-layout .start-new-conversation button.h-img-button:hover:not([disabled]),
  .hotline-launcher.h-open .viewport .h-conv .start-new-conversation button.h-img-button:hover:not([disabled]),
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .fc-carousel-wrapper .h-img-button:hover:not([disabled]),
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .button-region .h-img-button:hover:not([disabled]) {
    background-color: #25C16F !important;
    color: #FFFFFF;
  }

  .h-reply-wrapper .h-reply-button .btn-selected,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .fc-carousel-cards .h-img-button--selected,
  .h-chat-custom .h-conv .in-line-reply-fragments .h-conv-chat .h-img-button.btn-selected {
    background-color: #25C16F !important;
    color: #FFFFFF;
  }

  .d-hotline {
    background-color: #25C16F !important;
    color: #FFFFFF !important;
    border-color: transparent #25C16F transparent transparent;
  }

  #chat-icon {
    background: #FFFFFF !important;
  }

  #chat-icon::before, #chat-icon::after {
    background-color: #25C16F !important;
  }

  .loader {
    border-top: 1em solid rgba(#25C16F, 0.4);
    border-right: 1.05em solid #25C16F;
    border-bottom: 1.05em solid #25C16F;
    border-left: 1.05em solid #25C16F;
  }

  .article-modal .modal-footer .h-message-us-btn:hover,
  .article-modal .modal-footer .article_vote:hover {
    background-color: #25C16F !important;
    color : #FFFFFF !important;
  }

  /* .article-content .modal-footer .h-message-us-btn:hover,
  .article-content .modal-footer .article_vote:hover {
    background-color: #25C16F !important;
    color : #FFFFFF !important;
  } */

  .tabs .tabs-inner:after{
    background-color: #25C16F !important;
  }

  .chat-btn:hover{
    background-color: #25C16F !important;
    color: #FFFFFF !important;
    border: 0 !important;
  }

  .submit-rating .submit.btn {
    background-color: #25C16F !important;
    color: #FFFFFF !important;
  }

  .send-offline-reply .send-message {
    background-color: #25C16F !important;
    color: #FFFFFF !important;
  }

  .h-comment.h-wrapped-article .articles-listview .article-showmore,
  .fc-conversation-view div.body .h-chat-window .fc-agent-profile .u-social-network div i{
    color: #25C16F !important;
  }

  .h-chat-custom .odd .h-conv .h-comment.file-attached,
  .h-chat-custom .odd .h-conv .h-comment.media-message {
    background-color: unset !important;
  }

  .h-chat-custom .odd .h-conv .h-comment.file-attached .text-file-preview .text-haze-holder{
    background-color: #25C16F !important;
    color: #FFFFFF !important;
  }

  .h-chat-custom .odd .h-conv .h-comment.file-attached .text-file-preview .text-haze-holder .bottom-gradient {
    background: linear-gradient(180deg, rgba(255, 255, 255, 0) 0%, #25C16F 100%) !important;
  }

  .article-content .fc_web_modal_closed .article-header-section .progress-bar {
    background-color: #25C16F !important;
  }

  .preview-container .h-reply-button .h-button-area button,
  .h-reply-wrapper .h-reply-button .h-img-button,
  .actions-button-dropdown .h-img-button {
    border-color: #25C16F !important;
  }

  .h-header .jwt-error-message {
    color: #44412e !important;
    background-color: #ffac00 !important;
  }

  .cal-time-slot:hover {
      background-color: #25C16F;
  }
  .calendar-picker-minified .cal-picker-conf-view .confirm-button-holder .cal-confirm-button {
      background-color: #25C16F;
  }

  .meeting-frag-holder {
    background-color: #25C16F !important;
  }
  .meeting-frag-holder .event-header {
    color: #FFFFFF;
  }
  .h-conv-chat .h-chat .h-conv .h-comment .event-fragment .event-body .event-timings.actionable a{
      color: #25C16F;
  }

  .h-conv-chat .h-chat .h-conv .h-comment.emojis-1,
  .h-conv-chat .h-chat .h-conv .h-comment.emojis-2,
  .h-conv-chat .h-chat .h-conv .h-comment.emojis-3 {
    background-color: transparent !important;;
  }

  .h-reply-wrapper .ui-agent-typing-indicator {
    background-color: #25C16F;
  }

  .h-reply-wrapper .ui-agent-typing-indicator .indicator-dot {
    background-color: #FFFFFF;
  }

  .fc-mobile-close.minimize i.icon-ic_close{
    color: #FFFFFF;
  }
</style></div>
</body></html>